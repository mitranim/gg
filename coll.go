package gg

import "encoding/json"

/*
Short for "valid primary key". Returns the primary key generated by the given
input, asserts that the key is non-zero, and returns the resulting key.
Used internally by `Coll`.
*/
func ValidPk[
	Key comparable,
	Val Pker[Key],
](val Val) Key {
	key := val.Pk()
	if IsZero(key) {
		panic(Errf(`unexpected empty key of type %T for %#v`, key, val))
	}
	return key
}

/*
Syntactic shortcut for making a `Coll` of the given arguments, with type
inference. Reuses the given slice as-is with no reallocation.
*/
func CollOf[Key comparable, Val Pker[Key]](src ...Val) Coll[Key, Val] {
	var tar Coll[Key, Val]
	tar.Slice = src
	if src != nil {
		tar.Reindex()
	}
	return tar
}

/*
Syntactic shortcut for making a `Coll` from any number of source slices, with
type inference. When called with exactly one argument, this reuses the given
slice as-is with no reallocation.
*/
func CollFrom[Key comparable, Val Pker[Key], Slice ~[]Val](src ...Slice) Coll[Key, Val] {
	switch len(src) {
	case 1:
		return CollOf[Key, Val](src[0]...)
	default:
		var tar Coll[Key, Val]
		for _, src := range src {
			tar.Add(src...)
		}
		return tar
	}
}

/*
Short for "collection". Represents an ordered map where keys are automatically
derived from values. Keys must be non-zero. Similarly to a map, this ensures
value uniqueness by primary key, and allows efficient access by key. Unlike a
map, values in this type are ordered and can be iterated cheaply, because they
are stored in a publicly-accessible slice. However, as a tradeoff, this type
does not support deletion.
*/
type Coll[
	Key comparable,
	Val Pker[Key],
] struct {
	Slice []Val `role:"ref"`
	Index map[Key]int
}

// Same as `len(self.Slice)`.
func (self Coll[_, _]) Len() int { return len(self.Slice) }

// True if `.Len` <= 0. Inverse of `.IsNotEmpty`.
func (self Coll[_, _]) IsEmpty() bool { return self.Len() <= 0 }

// True if `.Len` > 0. Inverse of `.IsEmpty`.
func (self Coll[_, _]) IsNotEmpty() bool { return self.Len() > 0 }

/*
True if the index has the given key. Doesn't check if the index is within the
bounds of the inner slice.
*/
func (self Coll[Key, _]) Has(key Key) bool {
	_, ok := self.Index[key]
	return ok
}

// Returns the value indexed on the given key, or the zero value of that type.
func (self Coll[Key, Val]) Get(key Key) Val {
	return PtrGet(self.Ptr(key))
}

/*
Returns the value indexed on the given key and a boolean indicating if the value
was actually present.
*/
func (self Coll[Key, Val]) Got(key Key) (Val, bool) {
	ptr := self.Ptr(key)
	return PtrGet(ptr), ptr != nil
}

/*
Find the value indexed on the given key and returns the pointer to its position
in the slice. If the value is not found, returns nil. Caution: sorting the inner
slice invalidates such pointers.
*/
func (self Coll[Key, Val]) Ptr(key Key) *Val {
	ind, ok := MapGot(self.Index, key)
	if !ok {
		return nil
	}
	return GetPtr(self.Slice, ind)
}

/*
Idempotently adds each given value to both the inner slice and the inner index.
Every value whose key already exists in the index is replaced at the existing
position in the slice.
*/
func (self *Coll[Key, Val]) Add(src ...Val) *Coll[Key, Val] {
	index := MapInit(&self.Index)

	for _, val := range src {
		key := ValidPk[Key](val)
		ind, ok := index[key]
		if ok {
			self.Slice[ind] = val
			continue
		}
		index[key] = AppendIndex(&self.Slice, val)
	}

	return self
}

// Nullifies both the slice and the index. Does not preserve their capacity.
func (self *Coll[Key, Val]) Clear() *Coll[Key, Val] {
	if self != nil {
		self.Slice = nil
		self.Index = nil
	}
	return self
}

/*
Rebuilds the inner index from the inner slice, without checking the validity of
the existing index. Can be useful for external code that directly modifies the
inner `.Slice`, for example by sorting it. This is NOT used when adding items
via `.Add`, which modifies the index incrementally rather than all-at-once.
*/
func (self *Coll[Key, _]) Reindex() {
	slice := self.Slice
	if len(slice) <= 0 {
		return
	}

	index := make(map[Key]int, len(slice))
	for ind, val := range slice {
		index[ValidPk[Key](val)] = ind
	}
	self.Index = index
}

/*
Swaps two elements both in `.Slice` and in `.Index`. Useful for sorting.
`.Index` may be nil, in which case it's unaffected. Slice indices must be
either equal or valid.
*/
func (self Coll[Key, _]) Swap(ind0, ind1 int) {
	if ind0 == ind1 {
		return
	}

	slice := self.Slice
	val0, val1 := slice[ind0], slice[ind1]
	slice[ind0], slice[ind1] = val1, val0

	index := self.Index
	if index != nil {
		index[ValidPk[Key](val0)], index[ValidPk[Key](val1)] = ind1, ind0
	}
}

// Implement `json.Marshaler`. Encodes the inner slice, ignoring the index.
func (self Coll[_, _]) MarshalJSON() ([]byte, error) {
	return json.Marshal(self.Slice)
}

// Unmarshals the input into the inner slice and rebuilds the index.
func (self *Coll[_, _]) UnmarshalJSON(src []byte) error {
	err := json.Unmarshal(src, &self.Slice)
	self.Reindex()
	return err
}
